GFG: https://www.geeksforgeeks.org/problems/peak-element/1?page=1&category=Arrays&difficulty=Medium&status=solved&sortBy=submissions

IDEA

Idea lets us realize that a peak element is always guaranteed to exist in an array.

A peak element is:
Peak at index i â†’
arr[i] > arr[i-1] AND arr[i] > arr[i+1]

Instead of checking every element (which is slow), we observe:

If the right neighbor is greater â†’
A peak must exist on the right side.

If the left neighbor is greater â†’
A peak must exist on the left side.

Because:
Array always moves in an uphill or downhill pattern,
and an uphill must eventually become downhill â†’ creating a peak.

So we donâ€™t need to search the whole array.

THINK:
If slope goes up â†’ move right
If slope goes down â†’ move left

APPROACH

Approach lets us use Binary Search to find a peak in O(log n) time.

Steps thinking:

â€¢ If array has only one element â†’ it is the peak

â€¢ Check boundaries:
o If first element > second â†’ return 0
o If last element > second last â†’ return n-1

â€¢ Now apply Binary Search between 1 and n-2

At each step:

â€¢ Find mid

â€¢ If:
arr[mid] > arr[mid-1]
AND
arr[mid] > arr[mid+1]
â†’ mid is peak â†’ return mid

â€¢ If right neighbor is greater
â†’ Peak must exist on right side
â†’ Move lo = mid + 1

â€¢ Else
â†’ Peak must exist on left side
â†’ Move hi = mid - 1

After moving:
â€¢ We reduce search space by half
â€¢ Continue until peak is found

THINK:
Binary Search + move toward greater neighbor
Greater side always contains a peak ğŸš€


CODING
class Solution {
    public int peakElement(int[] arr) {
        // code here
        int n = arr.length;
        
        if (n == 1) {
            return 0;
        }
        
        if (arr[0] > arr[1]) {
            return 0;
        }
        
        if (arr[n - 2] < arr[n - 1]) {
            return n - 1;
        }
        
        int low = 1;
        int high = n - 2;
        
        while (low <= high) { // less than or eqaul to is used
            int mid = low + (high - low) / 2;
            
            if (arr[mid - 1] < arr[mid] && arr[mid] > arr[mid + 1]) {
                return mid;
            }
            
            if (arr[mid] < arr[mid + 1]) {
                low = mid + 1;
            }
            else {
                high = mid - 1;
            }
            
        }
        
        
        
        
    return 0;
    }
}
