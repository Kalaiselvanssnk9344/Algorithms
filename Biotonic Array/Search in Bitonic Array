INTERVIEW BIT: https://www.interviewbit.com/problems/search-in-bitonic-array/

IDEA

Idea lets us realize that a Bitonic Array has two parts:

â€¢ First part â†’ strictly increasing
â€¢ Second part â†’ strictly decreasing

Example:
-8, 1, 2, 3, 4, 5, -2, -3

Here:
Increasing â†’ -8 â†’ 5
Decreasing â†’ 5 â†’ -3

The highest element is called the Bitonic Point (Peak).

THINK:
Bitonic array = Increasing part + Peak + Decreasing part

Now, to search a key:

â€¢ If key is greater than peak â†’ impossible â†’ return -1
â€¢ If key equals peak â†’ return peak index
â€¢ Otherwise:
o Search in left (ascending) part
o If not found â†’ search in right (descending) part

Since both sides are sorted, we can use Binary Search.

THINK:
Find Peak â†’ Do Binary Search on both sides

APPROACH

Approach lets us solve the problem in 3 main steps using Binary Search logic.

STEP 1: Find Bitonic Point

We use a modified binary search:

â€¢ Find mid
â€¢ If:
arr[mid] > arr[mid-1]
AND
arr[mid] > arr[mid+1]
â†’ mid is the peak

â€¢ If array is still increasing
arr[mid] < arr[mid+1]
â†’ Peak lies on right
â†’ Search right half

â€¢ Else
â†’ Peak lies on left
â†’ Search left half

THINK:
If slope goes up â†’ move right
If slope goes down â†’ move left

Time: O(log n)

STEP 2: Search in Increasing Part

Use normal Binary Search:

â€¢ If mid > key â†’ move left
â€¢ If mid < key â†’ move right

Time: O(log n)

STEP 3: Search in Decreasing Part

Use modified Binary Search:

â€¢ If mid < key â†’ move left
â€¢ If mid > key â†’ move right

(Conditions reverse because array is descending)

Time: O(log n)

Final Complexity

â€¢ Finding peak â†’ O(log n)
â€¢ Searching left â†’ O(log n)
â€¢ Searching right â†’ O(log n)

Overall:
O(log n)

Final Thinking Structure

Bitonic Array
â†’ Find Peak
â†’ Binary Search Left
â†’ Binary Search Right

THINK:
Peak splits array into two sorted halves
Binary Search works because both halves are sorted ðŸš€


CODE:
public class Solution {
    
    public int findBitonicPoint(ArrayList<Integer> list) {
        int n = list.size();
        int low = 0;
        int high = n - 1;
        int idx = -1;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            
            if (list.get(mid - 1) < list.get(mid) && list.get(mid) > list.get(mid + 1)) {
                idx = mid;
                break;
            }
            
            if (list.get(mid) < list.get(mid + 1)) {
                low = mid + 1;
            }
            else {
                high = mid - 1;
            }
            
        }
        return idx;
    }
    
    public int searchInIncreasing(ArrayList<Integer> list, int high, int target) {
        int low = 0;
        int idx = -1;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            
            if (list.get(mid) == target) {
                idx = mid;
                break;
            }
            
            if (list.get(mid) < target) {
                low = mid + 1;
            }
            else {
                high = mid - 1;
            }
            
        }
        return idx;       
    }
    public int searchInDecreasing(ArrayList<Integer> list, int low, int target) {
        int high = list.size() - 1;
        int idx = -1;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            
            if (list.get(mid) == target) {
                idx = mid;
                break;
            }
            
            if (list.get(mid) < target) {
                high = mid - 1;
            }
            else {
                low = mid + 1;
            }
            
        }
        return idx; 
        
    }
    
    public int solve(ArrayList<Integer> A, int B) {
        
        int bitonicPoint = findBitonicPoint(A);
        
        int res = searchInIncreasing(A, bitonicPoint, B);
        
        if (res == -1) {
            res = searchInDecreasing(A, bitonicPoint + 1, B);
        }
        
        return res;    
    }
}
