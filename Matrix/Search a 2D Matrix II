LEETCODE: https://leetcode.com/problems/search-a-2d-matrix-ii/description/

IDEA

Idea lets us realize that the matrix is:

â€¢ Sorted row-wise (left â†’ right increasing)
â€¢ Sorted column-wise (top â†’ bottom increasing)

Example:

3   30   38
20  52   54
35  60   69

So from any element:

â€¢ Left side â†’ smaller
â€¢ Down side â†’ larger

This special structure allows us to eliminate one full row or one full column at every step.

THINK:
Use sorting property to eliminate space

APPROACH

Approach lets us start from the top-right corner.

Why top-right?

Because from there:
â€¢ Left â†’ smaller
â€¢ Down â†’ bigger

That gives us decision power.

Steps thinking:

â€¢ Start at:
i = 0
j = m - 1

â€¢ While inside matrix:

Case 1:
If x > mat[i][j]
â†’ x cannot be in that row (everything left is smaller)
â†’ Move down â†’ i++

Case 2:
If x < mat[i][j]
â†’ x cannot be in that column (everything below is larger)
â†’ Move left â†’ j--

Case 3:
If equal
â†’ Element found â†’ return true

If loop ends:
â†’ Element not present â†’ return false

Why this works?

Each step removes:
â€¢ One full row OR
â€¢ One full column

So total moves:
At most n + m

Time Complexity:
O(n + m)

Space Complexity:
O(1)

Final Thinking Structure

Row-wise sorted
Column-wise sorted

Start top-right
If bigger â†’ move down
If smaller â†’ move left

THINK:
Eliminate one row or one column every step ðŸš€

CODE:

class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;

        int i = 0;
        int j = n - 1;

        while (i < m && j >= 0) {
            if (matrix[i][j] < target) {
                i++;
            }
            else if (target < matrix[i][j]) {
                j--;
            }
            else {
                return true;
            }
        }

    return false;
    }
}
